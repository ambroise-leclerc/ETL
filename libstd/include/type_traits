/// @file <type_traits>
/// @data 07/03/2014 08:50:53
/// @author Ambroise Leclerc
/// @brief Traits : part of type support library
//
// Embedded Template Library
// Copyright (c) 2014, Ambroise Leclerc
//   All rights reserved.
//
//   Redistribution and use in source and binary forms, with or without
//   modification, are permitted provided that the following conditions are met:
//
//   * Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//   * Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in
//     the documentation and/or other materials provided with the
//     distribution.
//   * Neither the name of the copyright holders nor the names of
//     contributors may be used to endorse or promote products derived
//     from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
//  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
//  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
//  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
//  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
//  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
//  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
//  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
//  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
#pragma once

#include "cstdint"


namespace std {
/// Base class for type traits. Wraps a static constant of specified type.
template<typename T, T v>
struct integral_constant {
    static constexpr T value = v;
    using value_type = T;
    using type = integral_constant;
    constexpr operator value_type() const { return value; }
    constexpr value_type operator()() const { return value; }
};

using true_type =   integral_constant<bool, true>;	///> Specialization for type bool
using false_type =  integral_constant<bool, false>;  ///> Specialization for type bool


namespace etlHelper {
    template<typename> struct is_type_entier :      false_type { };
    template<> struct is_type_entier<bool> :        true_type { };
    template<> struct is_type_entier<int8_t> :      true_type { };
    template<> struct is_type_entier<uint8_t> :     true_type { };
    template<> struct is_type_entier<int16_t> :     true_type { };
    template<> struct is_type_entier<uint16_t> :    true_type { };
    template<> struct is_type_entier<int32_t> :     true_type { };
    template<> struct is_type_entier<uint32_t> :    true_type { };
    template<> struct is_type_entier<int64_t> :     true_type { };
    template<> struct is_type_entier<uint64_t> :    true_type { };
    template<typename> struct is_type_flottant :    false_type { };
    template<> struct is_type_flottant<float> :     true_type { };
    template<> struct is_type_flottant<double> :    true_type { };
    template<> struct is_type_flottant<long double> : true_type { };
    template<typename T> struct is_pointeur :       false_type { };
    template<typename T> struct is_pointeur<T*> :   true_type { };
    template<typename T> struct is_mb_pointeur :    false_type { };
} // namespace etlHelper 


/// Determines whether the two given types are equivalent.
template<typename T, typename U> struct is_same       : false_type {};
template<typename T>             struct is_same<T, T> : true_type {};  
 
/// Provides member typedef type, which is defined as T if B is true at
/// compile time, or as F if B is false.
template<bool, typename T, typename F>  struct conditional { using type = T; };
template<typename T, typename F>        struct conditional<false, T, F> { using type = F; };

/// Obtains the type T without const qualification.
template<typename T> struct remove_const          { using type = T; };
template<typename T> struct remove_const<const T> { using type = T; };
template<typename T> using remove_const_t = typename remove_const<T>::type;

/// Obtains the type T without volatile qualification. 
template<typename T> struct remove_volatile             { using type = T; };
template<typename T> struct remove_volatile<volatile T> { using type = T; };
template<typename T> using remove_volatile_t = typename remove_volatile<T>::type;

/// Obtains the type T without const or volatile qualification.
template<typename T> struct remove_cv {
    using type = typename std::remove_volatile<typename std::remove_const<T>::type>::type;
};
template<typename T> using remove_cv_t = typename remove_cv<T>::type;

/// Obtains the type T whithout reference.
template<typename T> struct remove_reference      { using type = T; };
template<typename T> struct remove_reference<T&>  { using type = T; };
template<typename T> struct remove_reference<T&&> { using type = T; };
template<typename T> using remove_reference_t = typename remove_reference<T>::type;
  
/// Obtains the type T without the eventual first array dimension.
template<typename T> struct remove_extent { using type = T; };
template<typename T> struct remove_extent<T[]> { using type = T; };
template<typename T, std::size_t N> struct remove_extent<T[N]> { using type = T; };
template<typename T> using remove_extent_t = typename remove_extent<T>::type;

/// Checks whether T is a void type. is_void< >::value equals true if T is of
/// type void, const void, volatile void, or const volatile void.
template<typename T>
struct is_void
    : std::integral_constant<bool, std::is_same<void, typename std::remove_cv<T>::type>::value>
{};

/// Checks if T is an union.
/// is_union::value is true if T is an union, false otherwise.                         
template<typename T> struct is_union : std::integral_constant<bool, __is_union(T)> { };
template<typename T> struct is_enum : std::integral_constant<bool, __is_enum(T)> { };
template<typename T> struct is_class : std::integral_constant<bool, __is_class(T)> { };
template<typename T> struct is_integral : etlHelper::is_type_entier<typename std::remove_cv<T>::type>::type { };
template<typename T> struct is_floating_point : etlHelper::is_type_flottant<typename std::remove_cv<T>::type>::type { };
template<typename T> struct is_pointer : etlHelper::is_pointeur<typename std::remove_cv<T>::type> {};
template<typename T> struct is_member_pointer : etlHelper::is_mb_pointeur<typename std::remove_cv<T>::type> {};


template<typename T>
struct is_arithmetic : std::integral_constant<bool,
    std::is_integral<T>::value ||
    std::is_floating_point<T>::value> { };

/// Checks if T is a scalar type.
/// is_scalar::value is true if T is a scalar type, false otherwise.  
template<typename T>
struct is_scalar : std::integral_constant<bool,
    std::is_arithmetic<T>::value ||
    std::is_enum<T>::value ||
    std::is_pointer<T>::value ||
    std::is_member_pointer<T>::value ||
    std::is_same<std::nullptr_t, typename std::remove_cv<T>::type>::value> { };

/// Checks if T is an array.
/// is_array::value is true if T is an array, false otherwise.                         
template<typename T> struct is_array : std::false_type { };
template<typename T> struct is_array<T[]> : std::true_type { };
template<typename T, std::size_t N> struct is_array<T[N]> : std::true_type { };



/// Checks if T is an object type (scalar, array, class, union).
/// is_object::value is true if T is an object, false otherwise.
template<typename T>
struct is_object : std::integral_constant<bool,
    std::is_scalar<T>::value ||
    std::is_array<T>::value ||
    std::is_union<T>::value ||
    std::is_class<T>::value> { };

/// Checks if T is a function type.
/// is_function::value is true if T is a function type, false otherwise
template<typename> struct is_function : std::false_type { };
// Regular functions
template<typename Ret, typename... Args> struct is_function<Ret(Args...)> : std::true_type {};

// Variadic functions
template<typename Ret, typename... Args> struct is_function<Ret(Args..., ...)> : std::true_type {};

// Function types with cv-qualifiers
template<typename Ret, typename... Args> struct is_function<Ret(Args...) const> : std::true_type {};
template<typename Ret, typename... Args> struct is_function<Ret(Args...) volatile> : std::true_type {};
template<typename Ret, typename... Args> struct is_function<Ret(Args...) const volatile> : std::true_type {};
template<typename Ret, typename... Args> struct is_function<Ret(Args..., ...) const> : std::true_type {};
template<typename Ret, typename... Args> struct is_function<Ret(Args..., ...) volatile> : std::true_type {};
template<typename Ret, typename... Args> struct is_function<Ret(Args..., ...) const volatile> : std::true_type {};

// Function types with ref-qualifiers
template<typename Ret, typename... Args> struct is_function<Ret(Args...) &> : std::true_type {};
template<typename Ret, typename... Args> struct is_function<Ret(Args...) const &> : std::true_type {};
template<typename Ret, typename... Args> struct is_function<Ret(Args...) volatile &> : std::true_type {};
template<typename Ret, typename... Args> struct is_function<Ret(Args...) const volatile &> : std::true_type {};
template<typename Ret, typename... Args> struct is_function<Ret(Args..., ...) &> : std::true_type {};
template<typename Ret, typename... Args> struct is_function<Ret(Args..., ...) const &> : std::true_type {};
template<typename Ret, typename... Args> struct is_function<Ret(Args..., ...) volatile &> : std::true_type {};
template<typename Ret, typename... Args> struct is_function<Ret(Args..., ...) const volatile &> : std::true_type {};
template<typename Ret, typename... Args> struct is_function<Ret(Args...) && > : std::true_type {};
template<typename Ret, typename... Args> struct is_function<Ret(Args...) const &&> : std::true_type {};
template<typename Ret, typename... Args> struct is_function<Ret(Args...) volatile &&> : std::true_type {};
template<typename Ret, typename... Args> struct is_function<Ret(Args...) const volatile &&> : std::true_type {};
template<typename Ret, typename... Args> struct is_function<Ret(Args..., ...) && > : std::true_type {};
template<typename Ret, typename... Args> struct is_function<Ret(Args..., ...) const &&> : std::true_type {};
template<typename Ret, typename... Args> struct is_function<Ret(Args..., ...) volatile &&> : std::true_type {};
template<typename Ret, typename... Args> struct is_function<Ret(Args..., ...) const volatile &&> : std::true_type {};



template<typename T> struct is_reference : std::false_type {};
template<typename T> struct is_reference<T&> : std::true_type {};
template<typename T> struct is_reference<T&&> : std::true_type {};

namespace etlHelper {
    template<typename T> struct is_referenceable
        : std::integral_constant<bool, (std::is_object<T>::value == true || std::is_reference<T>::value == true)>::type { };
    template<typename T, bool b> struct rvalue_reference_type { using type = T; };
    template<typename T> struct rvalue_reference_type<T, true> { using type = T&&; };

} // namespace etlHelper


template<typename T> struct is_rvalue_reference : std::false_type { };
template<typename T> struct is_rvalue_reference<T&&> : std::true_type { };
template<typename T> struct is_lvalue_reference : std::false_type { };
template<typename T> struct is_lvalue_reference<T&> : std::true_type { };

// Obtains a pointer on type T or on the referred type.
template<typename T> struct add_pointer {
  using type = typename std::remove_reference<T>::type*;
};
template<typename T> using add_pointer_t = typename add_pointer<T>::type;

  
template<typename T> struct add_rvalue_reference {
    using type = typename etlHelper::rvalue_reference_type< T, (std::is_void<T>::value == false && std::is_reference<T>::value == false)>::type;
};
template<typename T> struct add_lvalue_reference   { using type = T; };
    
template<typename T> using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;
template<typename T> using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;

namespace etlHelper {
    template<typename T> struct declval {
        static const bool never_use = false;
        static typename std::add_rvalue_reference<T>::type ret();
    };
} // namespace etlHelper 


/// Handles array decay and reference deferencing.
template<typename T> struct decay {
  using U = typename std::remove_reference<T>::type;
  using type =  typename std::conditional< 
				          std::is_array<U>::value,
			            typename std::remove_extent<U>::type*,
                  typename std::conditional< 
                    std::is_function<U>::value,
                    typename std::add_pointer<U>::type,
                    typename std::remove_cv<U>::type
                  >::type
                >::type;
};

template<typename T> using decay_t = typename std::decay<T>::type;
template<typename T> using add_pointer_t = typename add_pointer<T>::type;

template<typename T> struct add_const     { using type = const T; };
template<typename T> struct add_volatile  { using type = volatile T; };
template<typename T> struct add_cv        { using type = typename std::add_volatile<typename std::add_const<T>::type>::type; };
  
template<typename T> typename std::add_rvalue_reference<T>::type declval() noexcept {
    static_assert(etlHelper::declval<T>::never_use, "std::declval() return value must never be used (ISO §20.2.4).");
    return etlHelper::declval<T>::ret();
}

template<typename ...T> struct common_type;
template<typename T> struct common_type<T> {
    using type = std::decay_t<T>;
};
template<typename... T >
using common_type_t = typename common_type<T...>::type;

template<typename T1, typename T2>
struct common_type<T1, T2> {
    using type = std::decay_t<decltype(true ? std::declval<T1>() : std::declval<T2>())>;
};

template <typename T1, typename T2, typename... T3>
struct common_type<T1, T2, T3...> {
    using type = std::common_type_t<std::common_type_t<T1, T2>, T3...>;
};

} // namespace std

